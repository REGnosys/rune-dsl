/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.validation

import com.regnosys.rosetta.tests.util.ModelHelper
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static com.regnosys.rosetta.rosetta.expression.ExpressionPackage.Literals.*
import static com.regnosys.rosetta.rosetta.translate.TranslatePackage.Literals.*
import javax.inject.Inject

@ExtendWith(InjectionExtension)
@InjectWith(MyRosettaInjectorProvider)
class RosettaTranslateValidationTest implements RosettaIssueCodes {

	@Inject extension ValidationTestHelper
	@Inject extension ModelHelper
	
	@Test
	def void testDuplicateParameterNamesAreDisallowed() {
	    val model = '''
	    type Foo:
	       a string (1..1)
	    
	    type Bar:
	       b string (1..1)
	    
	    translate source FooBar {
	        Foo from var Bar, var string:
	        	+ a
	           		[from var]
	    }
	    '''.parseRosetta
		
		model.assertError(TRANSLATION_PARAMETER, null,
			"Duplicate parameter name `var`."
		)
	}
	
	@Test
	def void testMaxOneUnnamedParameter() {
	    val model = '''
	    type Foo:
	       a string (1..1)
	    
	    type Bar:
	       b string (1..1)
	    
	    translate source FooBar {
	        Foo from Bar, string:
	        	+ a
	           		[from b]
	    }
	    '''.parseRosetta
		
		model.assertError(TRANSLATION_PARAMETER, null,
			"Cannot have multiple unnamed parameters."
		)
	}
	
	@Test
	def void testMultiToSingleCardinalityIsDisallowed() {
	    val model = '''
	    type Foo:
	       a string (1..1)
	    
	    type Bar:
	       b string (0..2)
	    
	    translate source FooBar {
	        Foo from Bar:
	        	+ a
	           		[from b]
	    }
	    '''.parseRosetta
		
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null,
			"Expression must be of single cardinality when mapping to attribute `a` of single cardinality."
		)
	}
	
	@Test
	def void testTypeTranslationMustBeSingle() {
	    val model = '''
	    type Foo:
	       a string (1..1)
	    
	    type Bar:
	       b string (0..2)
	    
	    translate source FooBar {
	        Foo from Bar:
	        	[from b]
	        
	        Foo from string:
	        	+ a
	        		[from item]
	    }
	    '''.parseRosetta
		
		model.assertError(ROSETTA_EXPRESSION, null,
			"Expression must be of single cardinality when mapping to a type."
		)
	}
	
	@Test
	def void testMetaTranslationMustBeSingle() {
	    val model = '''	    
	    type Foo:
	    	a string (1..1)
	    		[metadata scheme]
	    
	    type Bar:
	    	b string (0..2)
	    
	    translate source FooBar {
	        Foo from Bar:
	        	+ a
	        		[meta scheme from b]
	    }
	    '''.parseRosetta
		
		model.assertError(ROSETTA_EXPRESSION, null,
			"Expression must be of single cardinality when mapping to attribute `scheme` of single cardinality."
		)
	}
	
	@Test
	def void testMatchingTranslationMustExist() {
	    val model = '''
	    type Foo:
	    	a string (1..1)
	    
	    type Bar:
	    	b Qux (1..1)
	    
	    type Qux:
	    	c string (1..1)
	    
	    translate source FooBar {
	        Foo from Bar:
	        	+ a
	           		[from b]
	    }
	    '''.parseRosetta
		
		model.assertError(TRANSLATE_INSTRUCTION, null,
			"No translation exists to translate Qux into string."
		)
	}
	
	@Test
	def void testMatchingTypeTranslationMustExist() {
	    val model = '''
	    type Foo:
	    	a string (1..1)
	    
	    type Bar:
	    	b Qux (1..1)
	    
	    type Qux:
	    	c string (1..1)
	    
	    translate source FooBar {
	        Foo from Bar:
	           	[from b]
	    }
	    '''.parseRosetta
		
		model.assertError(TRANSLATE_INSTRUCTION, null,
			"No translation exists to translate Qux into Foo."
		)
	}
	
	@Test
	def void testMatchingTranslationExists() {
	    '''
	    type Foo:
	    	a string (1..1)
	    
	    type Bar:
	    	b Qux (1..1)
	    
	    type Qux:
	    	c string (1..1)
	    
	    translate source FooBar {
	        Foo from Bar:
	        	+ a
	           		[from b, 42]
	        
	        string from Qux, context number:
	        	[from c]
	    }
	    '''.parseRosettaWithNoIssues
	}
	
	@Test
	def void testMatchingTranslationExistsInParent() {
	    '''
	    type Foo:
	    	a string (1..1)
	    
	    type Bar:
	    	b Qux (1..1)
	    
	    type Qux:
	    	c string (1..1)
	    
	    translate source Parent {
	        string from Qux:
	        	[from c]
	    }
	    
	    translate source FooBar extends Parent {
	        Foo from Bar:
	        	+ a
	           		[from b]
	    }
	    '''.parseRosettaWithNoIssues
	}
	
	@Test
	def void testMatchingTranslationWithExtendsExists() {
	    '''
	    type Foo:
	    	a AttrType (1..1)
	    
	    type SuperAttrType:
	    
	    type AttrType extends SuperAttrType:
	    	sub string (1..1)
	    
	    type Bar:
	    	b Qux (1..1)
	    
	    type SuperQux:
	    
	    type Qux extends SuperQux:
	    	c string (1..1)
	    
	    translate source FooBar {
	        Foo from Bar:
	        	+ a
	           		[from b]
	        
	        AttrType from SuperQux:
	    }
	    '''.parseRosettaWithNoIssues
	}
}
